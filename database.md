一、事务的概念和特性？
	概念：事务是一个操作序列，不可分割的工作单位，以begin transction开始，以rollback/commit结束
	特性(ACID):
		❶ 原子性(Atomicity)：逻辑上是不可分割的操作单元，事务的操作要么全部提交成功，要么全部失败回滚。
		❷ 一致性(Consistency):事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
		❸ 隔离性(Isolation):一个事务所做的修改在最终提交之前，对其他事务是不可见的。
		❹ 持久性(Durability)：一旦事务提交成功，对数据的修改是永久性的。

二、会出现哪些并发一致性的问题？
	• 丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。
	• 脏读：一个事务读取了被另一个事务修改，但未提交(进行了回滚)的数据，造成两个事务得到的数据不一致。
	• 不可重复读：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取改行数据，发现数据一经修改。
	• 幻读：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对insert操作）

三、数据库的四种隔离级别？
	• 未提交读：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、幻读、不可重复读。
	• 提交读：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题。
	• 可重复读：可以确保同一个事务在多次读取同样的数据时得到相同的结果。
	• 可串行化：强制事务串行执行，使之不可能相互冲突，从而解读幻读问题。可能导致大量的超时现象和锁竞争，实际上很少使用。

四、什么是乐观锁和悲观锁？
	悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其他事务读取或修改数据。应用于数据更新比较频繁的场景。
	乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。乐观锁的实现方式有：
		加一个版本号或时间戳字段，每次数据更新市同时更新这个字段
		先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。

五、常见的封锁类型？
	意向锁是 InnoDB 自动加的， 不需用户干预。 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)； 对于普通 SELECT 语句，InnoDB 不会加任何锁； 事务可以通过以下语句显式给记录集加共享锁或排他锁： 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁
		❶ 排它锁/X锁：事务对数据加上X锁，只允许此事务读取和修改此数据，并且其他事务不能对该数据加任何锁
		❷ 共享锁/S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁
		❸ 意向锁：
			一个事务在获得某个数据行对象的S锁之前，必须先获得整个表的IS锁或更强的锁。
			一个事务在获得某个数据行对象的X锁之前，必须先获得整个表的IX锁
			IS锁/IX锁之间都是兼容的
			好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了
	锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性

六、什么是三级封锁协议？
	• 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）
	• 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）
	• 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）

七、什么是两段锁协议？
	事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。
	可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。

八、什么是MVCC?
	多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号.

九、数据的三大范式？
	强调列的原子性，即数据库表的每一列都是不可分割的原子数据项
	要求实体的属性完全依赖于主关键字
	任何非主属性不依赖于其他非主属性

十、数据库的连接方式？
	内连接
	外连接
		左外连接
		右外连接
		全外连接
	交叉连接

十一、数据库索引的实现原理？
	InnoDB的索引使用的是B+树实现，B+树对比B树的好处：

		IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；
		范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；
		查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多
	使用B树索引和哈希索引的比较
		哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。

十二、使用索引的优点
	大大加快了数据的检索速度；
	可以显著减少查询中分组和排序的时间；
	通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；
	将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）
	缺点：建立和维护索引耗费时间空间，更新索引很慢。

十三、一条SQL语句在数据库框架中的执行流程？
	1. 应用程序把查询 SQL 语句发送给服务器端执行；
	2. 查询缓存，如果查询缓存是打开的，服务器在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据，如果存在，则直接返回给客户端。只有缓存不存在时，才会进行下面的操作；
	3. 查询优化处理，生成执行计划。这个阶段主要包括解析 SQL、预处理、优化 SQL 执行计划；
	4. MySQL 根据相应的执行计划完成整个查询；
	5. 将查询结果返回给客户端。
	
十四、char和varchar区别？
	**char(n) ：**固定长度类型，比如：订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。
	**varchar(n) ：**可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。
	所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。

十五、谈谈你对索引的理解？
	索引的出现是为了提高数据的查询效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。
	同样索引也会带来很多负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。
	**建立索引的原则：**
		1. 在最频繁使用的、用以缩小查询范围的字段上建立索引；
		2. 在频繁使用的、需要排序的字段上建立索引。
	**不适合建立索引的情况：**
		1. 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引；
		2. 对于一些特殊的数据类型，不宜建立索引，比如：文本字段（text）等。
	
十六、索引的分类？
	从数据结构分类：
		树索引
		Hash索引：哈希索引能够以O(1)时间进行查找，但是失去了有序性。无法用于排序与分组、只支持精确查找，无法用于部分查找和范围查找
			InnoDB存储引擎有一个特殊的功能叫"自适应哈希索引",当某个索引值被使用的非常频繁时，会在B+树索引上再创建一个哈希索引，这样就让树索引具有哈希索引的一些优点。
	从物理存储角度
		聚簇索引
			聚族索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一直。一般情况下，主键会默认创建聚族索引，且一张表只允许存在一个聚族索引.
		非聚簇索引
			非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据库的指针。
	从逻辑结构
		普通索引
		唯一索引
		主键索引
		联合索引
		全文索引

十七、怎么知道创建的索引有没有被使用到？
	使用 Explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possilbe_key、key、key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。

十八、InnoDB和MyISAM 的比较？
	1. 事务：MyISAM不支持事务，InnoDB支持事务；
	2. 全文索引：MyISAM 支持全文索引，InnoDB 5.6 之前不支持全文索引；
	3. 关于 count(*)：MyISAM会直接存储总行数，InnoDB 则不会，需要按行扫描。意思就是对于 select count(*) from table; 如果数据量大，MyISAM 会瞬间返回，而 InnoDB 则会一行行扫描；
	4. 外键：MyISAM 不支持外键，InnoDB 支持外键；
	5. 锁：MyISAM 只支持表锁，InnoDB 可以支持行锁。
	
十九、谈谈你对水平切分和垂直切分的理解？
	水平切分
		水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分不到集群的不同节点上，从而缓解单个数据库的压力。
	垂直切分
		垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如：将原来的电商数据库垂直切分成商品数据库、用户数据库等。

二十、主从复制中涉及到哪三个线程？
	1.binlog线程：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
	2.I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Relay log）中。
	3.SQL线程：负责读取重放日志并重放其中的 SQL 语句。